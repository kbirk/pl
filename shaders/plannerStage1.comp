#version 430

#define PL_MAX_GRID_POINTS          10000
#define PL_MAX_GRAFT_CAP_TRIANGLES  500
#define PL_MAX_CAPS_PER_SOLUTION    50
#define PL_MAX_SITE_TRIANGLE_COUNT  4000

#define PL_INITIAL_TEMP    1.0
#define PL_COOLING_RATE    0.0001

layout (local_size_x = 1024) in;

// input textures
layout (rgba32f, binding = 0) uniform image2D iGraftCaps;
layout (r32f,    binding = 1) uniform image1D iGraftAreas;
layout (rgba32f, binding = 2) uniform image2D iSiteMeshTriangles;

// input uniforms
uniform uint  uSiteGridSize;
uniform uint  uSiteMeshSize;
uniform float uSiteArea;
uniform vec3  uSiteNormal;


uniform float uTemperature;

uniform uint  uStateCount;
uniform float uStateEnergy;
uniform uint  uStateCaps[PL_MAX_CAPS_PER_SOLUTION];

// output textures


struct state
{
    uint  count;
    int   caps[PL_MAX_CAPS_PER_SOLUTION];
    float energy;
};


struct triangle
{
    vec3 p0;
    vec3 p1;
    vec3 p2;
    vec3 n;
};



float area( in triangle t)
{
    return 0.5 * cross( (t.p1 - t.p0),  (t.p2 - t.p0) ).length(); 
}

/*

void projectCap( int capID )
{
    vec3 plane_point = vec3( imageLoad( iSiteMeshTriangles, ivec2(0,0) ) ); // any point will doo

    for (uint i=0; i<PL_MAX_GRAFT_CAP_TRIANGLES; i++)
    {       
        vec3 p = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,0) ) );
        vec3 v = p - plane_point;
        
        float dist = dot( v, n );
        
        vec3 projected = p - dist*uSiteNormal; 
    }

}
*/


float area_covered( in state s )
{
    float total_area = 0;
    for (uint i = 0; i < s.count; i++)
    {   
        // add area of cap to sum, includes overlaps
        total_area += imageLoad( iGraftAreas, s.caps[i] ); 
    }
    return total_area;
}


float area_uncovered( in state s )
{   
    float areas[PL_MAX_SITE_TRIANGLE_COUNT];
    
    for (uint i = 0; i < PL_MAX_SITE_TRIANGLE_COUNT; i++)
    {  
        areas[i] = 0;
    }
    
    // for each graft in current state
    for (uint i = 0; i < s.count; i++)
    {   
        // for each triangle in that graft
        for (uint j = 0; j < PL_MAX_GRAFT_CAP_TRIANGLES; j+=4)
        { 
            // triangle points
            vec3 p0 = vec3( imageLoad( iGraftCaps, ivec2( i+0, s.caps[i]) )); 
            vec3 p1 = vec3( imageLoad( iGraftCaps, ivec2( i+1, s.caps[i]) )); 
            vec3 p2 = vec3( imageLoad( iGraftCaps, ivec2( i+2, s.caps[i]) )); 
        
            if (p0.x == -1)
                break;  // done with this graft cap
        
            // for each triangle in site mesh
            for (uint k = 0; k < uSiteMeshSize; k++)
            {   
                // create triangle struct
                triangle t;
                t.p0 = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,0) ) );
                t.p1 = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,1) ) );
                t.p2 = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,2) ) );
                t.n  = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,3) ) );
        
                if ( t.p0 == p0 || t.p0 == p1 || t.p0 == p2 ||
                     t.p1 == p0 || t.p1 == p1 || t.p1 == p2 ||
                     t.p2 == p0 || t.p2 == p1 || t.p2 == p2)
                {
                    if (areas[k] == 0)
                        areas[k] = area(t);
                }
            }
        }
        
    }
    
    float non_overlap_area = 0;
    
    for (uint i = 0; i < uSiteMeshSize; i++)
    {  
         non_overlap_area += areas[i];
    }      
    
    return uSiteArea - non_overlap_area;
}


float energy ( in state s )
{
    float WEIGHT = 0.4;
    return area_uncovered( s ) + WEIGHT * area_covered( s );
}


float acceptanceProbability( in float E, in float nE ) 
{
    // If the new solution is better, accept it
    if (nE < E) 
    {
        return 1.0;
    }
    // If the new solution is worse, calculate an acceptance probability
    return exp( (E - nE) / uTemperature );
}

void removeCap( inout state s, in uint index )
{
    // shift all other elements down
    for (uint i=index; i<s.count; i++)
    {
        if (i+1 == s.count)
            return;
        s.caps[i] == s.caps[i+1];       
    }
    s.count--;
}

float rand()
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);    
    return ( noise1( seed ) + 1.0 ) / 2.0;
}

void copyState( inout state nS, in state S )
{
    nS.count  = S.count;
    nS.energy = S.energy;        
    for (uint i=0; i<S.count; i++)
    {    
        nS.caps[i] = S.caps[i];
    }
}

int isInState( in state S, in int gid )
{
    for (int i=0; i<S.count; i++)
    {
        if (S.caps[i] == gid)
        {
            return i; 
        }
    }
    return -1;
}


void simulatedAnnealingIteration()
{
    // get global invocation id
    int gid = int( gl_GlobalInvocationID.x );    

    // initial state   
    S.count = 1;
    S.caps[0] = 0;
    S.energy = energy(S);
    
    float temperature = PL_INITIAL_TEMP;

    while (temperature > 0.000001)
    {
        // get copy of previous iteration        
        state nS;
        copyState( nS, S );
        
        // check if inside state
        int indexInState = isInState( nS, gid );
        
        if ( indexInState > 0 )
        {
            // remove self
            removeCap( nS, indexInState ); 
        }
        else
        {
            // add self
            nS.caps[ nS.count++ ] = gid;
        }
    
        nS.energy = energy( nS );
        

        temperature *= 1-PL_COOLING_RATE;
    }
   
}


void main(void)
{ 
    // get global invocation id
    int gid = int(gl_GlobalInvocationID.x);
    
    // get defect site position and normal
    vec3 position = vec3( imageLoad( iSiteGridPositions, gid ) );
    vec3 normal   = vec3( imageLoad( iSiteGridNormals,   gid ) );    
       
    gridPoint g;    
    g.p = position;
    g.n = normal;
    
    float area_sum = 0;
    int   num_tri  = 0;
    
    // iterate through each triangle in mesh
    for(uint i=0; i<uSiteMeshSize; i++)
    {
        // create triangle struct
        triangle t;
        t.p0 = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,0) ) );
        t.p1 = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,1) ) );
        t.p2 = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,2) ) );
        t.n  = vec3( imageLoad( iSiteMeshTriangles, ivec2(i,3) ) ); 
        
        float radius = 4.0;
        
        triangle tris[2];   // triangle(s) to be added to graft cap
        int num_results = intersectTriangle( tris, g, t, radius );  // num_results is the number of triangles returned, 0 <= t <= 2

        if (num_tri + num_results > PL_MAX_GRAFT_CAP_TRIANGLES) 
            break;  // exceeded max number of triangles (this shouldn't happen unless grafts have ridiculously large radii)

        for (uint j=0; j<num_results; j++)
        {
            // accumulate area
            area_sum += area( tris[j] );
            // store triangle           
            imageStore( oGraftCaps, ivec2( num_tri*4 + 0, gid ), vec4( tris[j].p0 + uSiteNormal * gid/50.0, 1) );
            imageStore( oGraftCaps, ivec2( num_tri*4 + 1, gid ), vec4( tris[j].p1 + uSiteNormal * gid/50.0, 1) );
            imageStore( oGraftCaps, ivec2( num_tri*4 + 2, gid ), vec4( tris[j].p2 + uSiteNormal * gid/50.0, 1) );
            imageStore( oGraftCaps, ivec2( num_tri*4 + 3, gid ), vec4( tris[j].n,  1) );            
            num_tri++;                   
        }                 
    }

    // ensure element is -1 to flag end of cap
    imageStore( oGraftCaps, ivec2( num_tri*4, gid ), vec4( -1, -1, -1, -1) );
    
    // write total cap area
    imageStore( oGraftAreas, gid, vec4( area_sum, 0, 0, 0) ); 
}


