#version 430

#define PL_FLT_MAX                  99999;
#define PL_MAX_GRAFTS_PER_SOLUTION  16
#define PL_MAX_DONOR_SITES          5
#define PL_MAX_CAP_TRIANGLES        1024

#define PL_DONOR_Z                  0, 0, 1

#define PL_NUM_COMPARISON_SLICES    8
#define PL_NUM_COMPARISON_RADII     4
#define PL_PI                       3.1415927

layout (local_size_x = 256) in;

// input data
layout (std430,  binding = 0) buffer defectSiteDataBlock  { vec4 defectSiteData[]; };
layout (std430,  binding = 1) buffer donorSiteDataBlock   { vec4 donorSiteData[];  };

// temporary data
layout (std430,  binding = 2) buffer tempBuffer0          { vec4 tempDefectTriangles[]; };
layout (std430,  binding = 3) buffer tempBuffer1          { vec4 tempDonorTriangles[];  };

// state output
layout (std430,  binding = 4) buffer rmsOutputBlock       { float rmsOutput[]; };

// input uniforms
uniform uint  uGraftCount;
uniform vec4  uGraftPositions [PL_MAX_GRAFTS_PER_SOLUTION];
uniform vec4  uGraftNormals   [PL_MAX_GRAFTS_PER_SOLUTION];
uniform float uGraftRadii     [PL_MAX_GRAFTS_PER_SOLUTION];

uniform uint  uDefectSiteMeshSize;

uniform uint  uDonorSiteCount;
uniform uint  uDonorSiteMeshSize   [PL_MAX_DONOR_SITES];
uniform uint  uDonorSiteGridSize   [PL_MAX_DONOR_SITES];
uniform uint  uDonorSitePerimSize  [PL_MAX_DONOR_SITES];

uniform vec4  uDefectZ;

struct triangle
{
    vec3 p0;
    vec3 p1;
    vec3 p2;
    vec3 n;
};


struct edge
{
    vec3 p0;
    vec3 p1;
    vec3 n;
};


triangle defectSiteTriangles( in uint i )
{
    uint j = i*4;    
    triangle t;
    t.p0 = vec3( defectSiteData[j+0] );
    t.p1 = vec3( defectSiteData[j+1] );
    t.p2 = vec3( defectSiteData[j+2] );
    t.n  = vec3( defectSiteData[j+3] );
    return t;
}

triangle defectCapTriangles( in uint i )
{
    uint offset = gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES * 4;
    uint j = i*4;  
    triangle t;
    t.p0 = vec3( tempDefectTriangles[ offset + j+0 ] );
    t.p1 = vec3( tempDefectTriangles[ offset + j+1 ] );
    t.p2 = vec3( tempDefectTriangles[ offset + j+2 ] );
    t.n  = vec3( tempDefectTriangles[ offset + j+3 ] );
    return t;
}


void defectCapTriangles( in uint i, in triangle t, in vec3 position )
{
    uint offset = gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES * 4;
    uint j = i*4;
    // subtract position from triangles for normalized coordinate system 
    tempDefectTriangles[ offset + j+0 ] = vec4( t.p0-position, 1.0 );
    tempDefectTriangles[ offset + j+1 ] = vec4( t.p1-position, 1.0 );
    tempDefectTriangles[ offset + j+2 ] = vec4( t.p2-position, 1.0 );
    tempDefectTriangles[ offset + j+3 ] = vec4( t.n,  1.0 );
}


void getDonorSiteAndIndex( inout uint site, inout uint localIndex )
{
    localIndex = gl_GlobalInvocationID.x;
    for (uint i=0; i<uDonorSiteCount; i++)
    {
        if ( localIndex < uDonorSiteGridSize[ i ] )
        {
            site = i;
            break;
        }
        localIndex -= uDonorSiteGridSize[ i ];
    }
}


uint getDonorSiteOffset( in uint site )
{
    uint offset = 0;
    for (uint i=0; i<site; i++)
    {
        offset += uDonorSiteGridSize[i]*2 + uDonorSiteMeshSize[i]*4 + uDonorSitePerimSize[i]*2;
    }
    return offset;
}


vec4 donorSitePositions( in uint site, in uint i )
{   
    return donorSiteData[ getDonorSiteOffset( site ) + i ];
}


vec4 donorSiteNormals( in uint site, in uint i )
{
    return donorSiteData[ getDonorSiteOffset( site ) + uDonorSiteGridSize[ site ] + i];
}


triangle donorSiteTriangles( in uint site, in uint i )
{
    uint j = getDonorSiteOffset( site ) + uDonorSiteGridSize[ site ]*2 + i*4;  
    triangle t;
    t.p0 = vec3( donorSiteData[j+0] );
    t.p1 = vec3( donorSiteData[j+1] );
    t.p2 = vec3( donorSiteData[j+2] );
    t.n  = vec3( donorSiteData[j+3] );
    return t;
}


triangle donorCapTriangles( in uint i )
{
    uint offset = gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES * 4;
    uint j = i*4;  
    triangle t;
    // subtract position from triangles for normalized coordinate system 
    t.p0 = vec3( tempDonorTriangles[ offset + j+0 ] );
    t.p1 = vec3( tempDonorTriangles[ offset + j+1 ] );
    t.p2 = vec3( tempDonorTriangles[ offset + j+2 ] );
    t.n  = vec3( tempDonorTriangles[ offset + j+3 ] );
    return t;
}


void donorCapTriangles( in uint i, in triangle t, in vec3 position )
{
    uint offset = gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES * 4;
    uint j = i*4;
    tempDonorTriangles[ offset + j+0 ] = vec4( t.p0-position, 1.0 );
    tempDonorTriangles[ offset + j+1 ] = vec4( t.p1-position, 1.0 ); 
    tempDonorTriangles[ offset + j+2 ] = vec4( t.p2-position, 1.0 );
    tempDonorTriangles[ offset + j+3 ] = vec4( t.n,  1.0 );
}


edge donorSiteEdge( in uint site, in uint i )
{
    uint offset = getDonorSiteOffset( site ) + uDonorSiteGridSize[ site ]*2 + uDonorSiteMeshSize[ site ]*4; 

    uint j = offset + i;
    uint k = offset + ( (i+1) % uDonorSitePerimSize[ site ] );
    
    edge e;
    e.p0 = vec3( donorSiteData[ j ] );
    e.p1 = vec3( donorSiteData[ k ] );  
    e.n  = vec3( donorSiteData[ j + uDonorSitePerimSize[ site ] ] );
    return e;
}


vec3 closestPointOnSegment( in vec3 p, in vec3 a, in vec3 b)
{
    vec3 ab = b - a;
    float t = dot( (p - a), ab) / dot(ab, ab);
    // If outside segment, clamp t (and therefore d) to the closest endpoint
    t = clamp( t, 0.0, 1.0 );
    // Compute projected position from the clamped t
    return a + (t * ab);
}


vec3 closestPointOnSegment( in vec3 p, in edge e)
{
    return closestPointOnSegment( p, e.p0, e.p1 );
}


bool isWithinSite( in uint site, in vec3 pos, in float radius )
{
    bool inside = true;
    for (int i=0; i<uDonorSitePerimSize[ site ]; i++)
    {
        edge e = donorSiteEdge( site, i );
        if ( distance( pos, closestPointOnSegment( pos, e ) ) < radius )
        {
            inside = false;
        }        
    }    
    return inside;
}


float distToAxis( in vec3 axis, in vec3 v )    
{
    // v is already in the *local* coordinate system of the graft        
    return distance( v, dot( v, axis )*axis );
}


bool intersectTriangle( in vec3 position, in vec3 normal, in triangle t, in float radius ) 
{
    if ( dot( t.n, normal ) < 0 )
        return false;

    // get vector from graft centre to triangle point
    vec3 point0 = t.p0 - position;
    vec3 point1 = t.p1 - position;
    vec3 point2 = t.p2 - position;
    
    return ( distToAxis( normal, point0 ) < radius ||   // check vertices first
             distToAxis( normal, point1 ) < radius ||
             distToAxis( normal, point2 ) < radius ||
             distance( closestPointOnSegment( position, t.p0, t.p1 ), position ) < radius ||    // check edges after (in case no vertex is inside)
             distance( closestPointOnSegment( position, t.p1, t.p2 ), position ) < radius ||
             distance( closestPointOnSegment( position, t.p2, t.p0 ), position ) < radius );
}


uint calculateDefectCap( in vec3 position, in vec3 normal, in float radius )
{ 
    uint triangleCount = 0;
    
    for(uint i=0; i<uDefectSiteMeshSize; i++)
    {
        // create triangle struct
        triangle tri = defectSiteTriangles( i );

        if ( intersectTriangle( position, normal, tri, radius ) )
        {
            // if intersected by graft cap, add to temp array
            defectCapTriangles( triangleCount, tri, position );
            triangleCount++;
        }
    }
    return triangleCount;
}


uint calculateDonorCap( in uint site, in vec3 position, in vec3 normal, in float radius )
{    
    uint triangleCount = 0;
    
    for(uint i=0; i<uDonorSiteMeshSize[ site ]; i++)
    {
        // create triangle struct
        triangle tri = donorSiteTriangles( site, i );

        if ( intersectTriangle( position, normal, tri, radius ) )
        {
            // if intersected by graft cap, add to temp array
            donorCapTriangles( triangleCount, tri, position );
            triangleCount++;
        }
    }
    return triangleCount;
}


bool rayIntersect( inout vec3 point, inout float t, in vec3 rayStart, in vec3 rayDir, in triangle tri )
{
    bool result = false;

    float dn = dot( rayDir, tri.n );

    if (dn != 0.0 )
    {      
        float dist = dot( tri.p0, tri.n );

        t = ( dist - dot( rayStart, tri.n ) ) / dn;
        
        point = rayStart + t * rayDir;

        // Compute barycentric coords
        float totalAreaDiv = 1.0 / dot( cross( tri.p1-tri.p0, tri.p2-tri.p0 ), tri.n);
        float u = dot( cross( tri.p2-tri.p1, point-tri.p1 ), tri.n) * totalAreaDiv;
        float v = dot( cross( tri.p0-tri.p2, point-tri.p2 ), tri.n) * totalAreaDiv;

        // Reject if outside triangle
        if (u < -0.0001 || v < -0.0001 || u + v > 1.0001)
        {
            result = false; 
        }
        else
        {
            result = true;
        }
    }
    else
    {
        // ray is parallel to plane 
        result = false;        
    }

    return result;
}


bool rayIntersectDefect( inout vec3 point, in vec3 rayStart, in vec3 rayDir, in uint count )
{
    bool result = false;
    float minT = PL_FLT_MAX;
    for (uint i=0; i<count; i++)
    {
        triangle tri = defectCapTriangles( i );
        vec3 p;
        float t;
        if ( rayIntersect( p, t, rayStart, rayDir, tri ) )
        { 
            result = true;
            if ( abs( t ) < minT )
            {
                minT = abs( t );
                point = p;
            }
        }
    }
    return result;
}



bool rayIntersectDonor( inout vec3 point, in vec3 rayStart, in vec3 rayDir, in uint count )
{
    bool result = false;
    float minT = PL_FLT_MAX;
    for (uint i=0; i<count; i++)
    {
        triangle tri = donorCapTriangles( i );
        vec3 p;
        float t;
        if ( rayIntersect( p, t, rayStart, rayDir, tri ) )
        {
            result = true;
            if ( abs( t ) < minT )
            {
                minT = abs( t );
                point = p;                
            }
        }
    }
    return result;
}


float calcRMS( in uint defectCount, in uint donorCount, in vec3 defectNormal, in vec3 donorNormal, in float radius )
{
    // ray intersect at certain points, and calc distance
    
    // get coordinate systems for grafts
    vec3 defectX = normalize( cross( defectNormal, vec3( uDefectZ ) ) );
    vec3 defectZ = normalize( cross( defectX, defectNormal ) );
    
    vec3 donorX = normalize( cross( donorNormal, vec3( PL_DONOR_Z ) ) );
    vec3 donorZ = normalize( cross( donorX, donorNormal ) );

    uint  successfulChecks   = 0;
    float squaredDistanceSum = 0;
    
    float dr = (radius / float(PL_NUM_COMPARISON_RADII)) * 0.8; //- 0.01;     // SOMETHING IS WRONG EHRE!!
    float da = (2.0f * PL_PI) / float(PL_NUM_COMPARISON_SLICES);
    
    for (uint i=1; i<=PL_NUM_COMPARISON_RADII; i++)
    { 
        for (uint j=0; j < PL_NUM_COMPARISON_SLICES; j++)
        {       
            float theta = j * da;
                
            float sa = sin( theta );
            float ca = cos( theta );
    
            vec3 defectCast = normalize( defectX * sa + defectZ * ca ) * (dr * i);
            vec3 donorCast  = normalize( donorX  * sa + donorZ  * ca ) * (dr * i);
            
            vec3 defectPoint, donorPoint;
            bool i0 = rayIntersectDefect( defectPoint, defectCast, defectNormal, defectCount );
            bool i1 = rayIntersectDonor ( donorPoint,  donorCast,  donorNormal,  donorCount  );   
            
            if ( i0 && i1 ) // this should never fail!  
            {    
                float distance = distance( defectPoint, donorPoint );                
                squaredDistanceSum += distance * distance;
                successfulChecks++;
            }
            else
            {
                squaredDistanceSum += 10000.0;
            }
        }       
    }

    return sqrt( squaredDistanceSum / float( successfulChecks ) );
}


void main(void)
{ 
    // get specific defect site and local index of grid point
    uint site, localIndex;
    getDonorSiteAndIndex( site, localIndex );
    
    // get grid point
    vec3 gridPosition = vec3( donorSitePositions( site, localIndex ) );
    vec3 gridNormal   = vec3( donorSiteNormals  ( site, localIndex ) );
    
    // for each graft in solution
    for (uint i=0; i<uGraftCount; i++)
    {
        float rms;
        if ( isWithinSite( site, gridPosition, uGraftRadii[i] ) )
        {
            vec3 graftPosition = vec3( uGraftPositions[i] );
            vec3 graftNormal   = vec3( uGraftNormals  [i] );
            
            // calculate defect cap triangles and store in temp buffer
            uint defectCount = calculateDefectCap( graftPosition, graftNormal, uGraftRadii[i] );
            // calculate cap triangles and store in temp buffer
            uint donorCount  = calculateDonorCap( site, gridPosition, gridNormal, uGraftRadii[i] );
            // calculate rms error
            rms = calcRMS( defectCount, donorCount, graftNormal, gridNormal, uGraftRadii[i] );  
        }
        else
        {
            // doesnt fit in boundary
            rms = -1;
        }
        rmsOutput[ gl_GlobalInvocationID.x * PL_MAX_GRAFTS_PER_SOLUTION + i] = rms;            
    }    
    
}


