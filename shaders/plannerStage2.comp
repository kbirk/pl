#version 430

#define PL_FLT_MAX                  99999;
#define PL_MAX_GRAFTS_PER_SOLUTION  16
#define PL_MAX_DONOR_SITES          5
#define PL_MAX_CAP_TRIANGLES        2048

#define PL_DONOR_Z                  0, 0, 1

#define PL_NUM_COMPARISON_SLICES    16
#define PL_NUM_COMPARISON_RADII     4
#define PL_PI                       3.1415927

layout (local_size_x = 1024) in;

// input data
layout (std430,  binding = 0) buffer defectSiteDataBlock  { vec4 defectSiteData[]; };
layout (std430,  binding = 1) buffer donorSiteDataBlock   { vec4 donorSiteData[];  };

// temporary data
layout (std430,  binding = 2) buffer tempBuffer0          { uint defectCapIndices[]; };
layout (std430,  binding = 3) buffer tempBuffer1          { uint donorCapIndices[];  };

// state output
layout (std430,  binding = 4) buffer rmsOutputBlock       { float rmsOutput[]; };

// input uniforms
uniform uint  uGraftCount;
uniform vec4  uGraftPositions [PL_MAX_GRAFTS_PER_SOLUTION];
uniform vec4  uGraftNormals   [PL_MAX_GRAFTS_PER_SOLUTION];
uniform float uGraftRadii     [PL_MAX_GRAFTS_PER_SOLUTION];

uniform uint  uDefectSiteMeshSize;

uniform uint  uDonorSiteCount;
uniform uint  uDonorSiteMeshSize   [PL_MAX_DONOR_SITES];
uniform uint  uDonorSiteGridSize   [PL_MAX_DONOR_SITES];
uniform uint  uDonorSitePerimSize  [PL_MAX_DONOR_SITES];
uniform uint  uDonorSiteDataOffset [PL_MAX_DONOR_SITES];

uniform vec4  uDefectZ;

struct triangle
{
    vec3 p0;
    vec3 p1;
    vec3 p2;
    vec3 n;
};


struct edge
{
    vec3 p0;
    vec3 p1;
    vec3 n;
};


// defect
triangle defectCapTriangles( in uint graftIndex, in vec3 graftPosition, in uint index )
{
    uint offset   = (graftIndex * PL_MAX_CAP_TRIANGLES) + 1; // + 1 triangle count is [0]    
    uint triIndex = defectCapIndices[ offset+index ] * 4;    // get triangle index
    
    triangle t;
    t.p0 = vec3( defectSiteData[triIndex+0] ) - graftPosition;  // subtract graft position to set cap centre to origin
    t.p1 = vec3( defectSiteData[triIndex+1] ) - graftPosition;
    t.p2 = vec3( defectSiteData[triIndex+2] ) - graftPosition;
    t.n  = vec3( defectSiteData[triIndex+3] );
    return t;
}
    

uint defectCapCount( in uint graftIndex )
{
    uint offset = graftIndex * PL_MAX_CAP_TRIANGLES; 
    return defectCapIndices[ offset ];
} 


// donor
void getDonorSiteAndIndex( inout uint site, inout uint localIndex )
{
    localIndex = gl_GlobalInvocationID.x;
    for (uint i=0; i<uDonorSiteCount; i++)
    {
        if ( localIndex < uDonorSiteGridSize[ i ] )
        {
            site = i;
            break;
        }
        localIndex -= uDonorSiteGridSize[ i ];
    }
}


vec4 donorSitePositions( in uint site, in uint i )
{   
    return donorSiteData[ uDonorSiteDataOffset[ site ] + i ];
}


vec4 donorSiteNormals( in uint site, in uint i )
{
    return donorSiteData[ uDonorSiteDataOffset[ site ] + uDonorSiteGridSize[ site ] + i];
}


edge donorSiteEdge( in uint site, in uint i )
{
    uint offset = uDonorSiteDataOffset[ site ] + uDonorSiteGridSize[ site ]*2 + uDonorSiteMeshSize[ site ]*4; 

    uint j = offset + i;
    uint k = offset + ( (i+1) % uDonorSitePerimSize[ site ] );
    
    edge e;
    e.p0 = vec3( donorSiteData[ j ] );
    e.p1 = vec3( donorSiteData[ k ] );  
    e.n  = vec3( donorSiteData[ j + uDonorSitePerimSize[ site ] ] );
    return e;
}

      
triangle donorCapTriangles( in uint site, in vec3 gridPosition, in uint index )
{
    uint offset   = (gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES) + 1; // + 1 triangle count is [0]    
    uint triIndex =  uDonorSiteDataOffset[ site ] + uDonorSiteGridSize[ site ]*2 + donorCapIndices[ offset+index ]*4; // get triangle index

    triangle t;
    t.p0 = vec3( donorSiteData[triIndex+0] ) - gridPosition;  // subtract grid position to set cap centre to origin
    t.p1 = vec3( donorSiteData[triIndex+1] ) - gridPosition;
    t.p2 = vec3( donorSiteData[triIndex+2] ) - gridPosition;
    t.n  = vec3( donorSiteData[triIndex+3] );
    return t;
}
    

uint donorCapCount()
{
    uint offset = gl_GlobalInvocationID.x * PL_MAX_CAP_TRIANGLES; 
    return donorCapIndices[ offset ];
} 


vec3 closestPointOnSegment( in vec3 p, in vec3 a, in vec3 b)
{
    vec3 ab = b - a;
    float t = dot( (p - a), ab) / dot(ab, ab);
    // If outside segment, clamp t (and therefore d) to the closest endpoint
    t = clamp( t, 0.0, 1.0 );
    // Compute projected position from the clamped t
    return a + (t * ab);
}


vec3 closestPointOnSegment( in vec3 p, in edge e)
{
    return closestPointOnSegment( p, e.p0, e.p1 );
}


bool isWithinSite( in uint site, in vec3 position, in vec3 normal, in float radius )
{
    // checks if closest point on all edges is within radius distance to the grafts central axis
    bool inside = true;
    for (int i=0; i<uDonorSitePerimSize[ site ]; i++)
    {
        edge e = donorSiteEdge( site, i );              
        vec3 closestPoint     = closestPointOnSegment( position, e ) - position;    // get closest point in graft coords        
        vec3 projClosestPoint = dot( closestPoint, normal ) * normal;               // get closest point projected onto graft axis
        // check if within radius distance
        if ( distance( closestPoint, projClosestPoint ) < radius )                  
        {
            inside = false;
        }        
    }    
    return inside;
}


bool rayIntersect( inout vec3 point, inout float t, in vec3 rayStart, in vec3 rayDir, in triangle tri )
{
    bool result = false;

    float dn = dot( rayDir, tri.n );

    if ( dn != 0.0 )
    {      
        float dist = dot( tri.p0, tri.n );

        t = ( dist - dot( rayStart, tri.n ) ) / dn;
        
        point = rayStart + t * rayDir;

        // Compute barycentric coords
        float totalAreaDiv = 1.0 / dot( cross( tri.p1-tri.p0, tri.p2-tri.p0 ), tri.n);
        float u = dot( cross( tri.p2-tri.p1, point-tri.p1 ), tri.n) * totalAreaDiv;
        float v = dot( cross( tri.p0-tri.p2, point-tri.p2 ), tri.n) * totalAreaDiv;

        // Reject if outside triangle
        if (u < -0.0001 || v < -0.0001 || u + v > 1.0001 )
        {
            result = false; 
        }
        else
        {
            result = true;
        }
        
    }
    else
    {
        // ray is parallel to plane 
        result = false;        
    }

    return result;
}


bool rayIntersectDefect( inout vec3 point, in vec3 rayStart, in vec3 rayDir, in vec3 graftPosition, in uint graftIndex )
{
    bool result = false;
    float minT = PL_FLT_MAX;
    
    uint count = defectCapCount( graftIndex );
    for (uint i=0; i< count; i++)
    {
        triangle tri = defectCapTriangles( graftIndex, graftPosition, i );
        vec3  p;
        float t;
        if ( rayIntersect( p, t, rayStart, rayDir, tri ) )
        { 
            result = true;
            if ( abs( t ) < minT )
            {
                minT = abs( t );
                point = p;
            }
        }
    }
    return result;
}


bool rayIntersectDonor( inout vec3 point, in vec3 rayStart, in vec3 rayDir, in vec3 gridPosition, in uint siteIndex )
{
    bool result = false;
    float minT = PL_FLT_MAX;
    
    uint count = donorCapCount();
    for (uint i=0; i<count; i++)
    {
        triangle tri = donorCapTriangles( siteIndex, gridPosition, i );
        vec3  p;
        float t;
        if ( rayIntersect( p, t, rayStart, rayDir, tri ) )
        {
            result = true;
            if ( abs( t ) < minT )
            {
                minT = abs( t );
                point = p;                
            }
        }
    }
    return result;
}


float calcRMS( in vec3 defectPosition, in vec3 donorPosition, in vec3 defectNormal, in vec3 donorNormal, in float radius, in uint siteIndex, in uint graftIndex )
{
    // ray intersect at certain points, and calc distance
    
    // get coordinate systems for grafts
    vec3 defectX = normalize( cross( defectNormal, vec3( uDefectZ ) ) );
    vec3 defectZ = normalize( cross( defectX, defectNormal ) );
    
    vec3 donorX = normalize( cross( donorNormal, vec3( PL_DONOR_Z ) ) );
    vec3 donorZ = normalize( cross( donorX, donorNormal ) );

    uint  successfulChecks   = 0;
    float squaredDistanceSum = 0.0;
    
    float dr = (radius / float(PL_NUM_COMPARISON_RADII)) - 0.01;
    float da = (2.0f * PL_PI) / float(PL_NUM_COMPARISON_SLICES);
    
    for (uint i=1; i<=PL_NUM_COMPARISON_RADII; i++)
    { 
        for (uint j=0; j < PL_NUM_COMPARISON_SLICES; j++)
        {       
            float theta = j * da;
                
            float sa = sin( theta );
            float ca = cos( theta );
    
            vec3 defectCast = normalize( defectX * sa + defectZ * ca ) * (dr * i);
            vec3 donorCast  = normalize( donorX  * sa + donorZ  * ca ) * (dr * i);
            
            vec3 defectIntPoint, donorIntPoint;
            bool i0 = rayIntersectDefect( defectIntPoint, defectCast, defectNormal, defectPosition, graftIndex );
            bool i1 = rayIntersectDonor ( donorIntPoint,  donorCast,  donorNormal,  donorPosition, siteIndex  );   
            
            if ( i0 && i1 )
            {    
                // intersection failures may occur if defect grafts overlap boundaries ( thus missing triangles on cap )
                float distance = dot( defectIntPoint, defectNormal ) - dot( donorIntPoint, donorNormal );               
                squaredDistanceSum += distance * distance;
                successfulChecks++;
            }
        }       
    }

    return sqrt( squaredDistanceSum / float( successfulChecks ) );
}


void main(void)
{ 
    // get specific defect site and local index of grid point
    uint siteIndex, localIndex;
    getDonorSiteAndIndex( siteIndex, localIndex );
    
    // get grid point
    vec3 gridPosition = vec3( donorSitePositions( siteIndex, localIndex ) );
    vec3 gridNormal   = vec3( donorSiteNormals  ( siteIndex, localIndex ) );
    
    // for each graft in solution
    for (uint i=0; i<uGraftCount; i++)
    {
        vec3 graftPosition = vec3( uGraftPositions[i] );
        vec3 graftNormal   = vec3( uGraftNormals  [i] );
        
        float rms;
        
        if ( isWithinSite( siteIndex, gridPosition, gridNormal, uGraftRadii[i] ) )
        {
            rms = calcRMS( graftPosition, gridPosition, graftNormal, gridNormal, uGraftRadii[i], siteIndex, i );  
        }
        else
        {
            // doesnt fit in boundary
            rms = -1;
        }
        rmsOutput[ gl_GlobalInvocationID.x * PL_MAX_GRAFTS_PER_SOLUTION + i ] = rms;
    } 
    
}


