#version 430

#define PL_FLT_MAX                  99999
#define PL_MAX_GRAFTS_PER_SOLUTION  16
#define PL_MAX_DONOR_SITES          5
#define PL_ITERATIONS               50


layout (local_size_x = 256) in;

// input data
layout (std430,  binding = 0) buffer donorSiteDataBlock   { vec4 donorSiteData[];  };
layout (std430,  binding = 1) buffer rmsInputBlock        { float rmsInput[];      };

// output data
layout (std430,  binding = 2) buffer donorPositionsBlock   { vec4  donorPositionsOutput  []; };
layout (std430,  binding = 3) buffer donorNormalsBlock     { vec4  donorNormalsOutput    []; };
layout (std430,  binding = 4) buffer donorDirectionsBlock  { vec4  donorZDirectionOutput []; };
layout (std430,  binding = 5) buffer totalRmsBlock         { float totalRmsOutput[];         };

// input uniforms
uniform uint  uGraftCount;
uniform float uGraftRadii     [PL_MAX_GRAFTS_PER_SOLUTION];

uniform uint  uTotalGridPoints;
uniform uint  uDonorSiteCount;
uniform uint  uDonorSiteGridSize   [PL_MAX_DONOR_SITES];

uniform uint uSeed;

void getDonorSiteAndIndex( inout uint site, inout uint localIndex, in uint globalIndex )
{
    localIndex = globalIndex;
    for (uint i=0; i<uDonorSiteCount; i++)
    {
        if ( localIndex < uDonorSiteGridSize[ i ] )
        {
            site = i;
            break;
        }
        localIndex -= uDonorSiteGridSize[ i ];
    }
}


uint getDonorSiteOffset( in uint site )
{
    uint offset = 0;
    for (uint i=0; i<site; i++)
    {
        offset += uDonorSiteGridSize[i]*2;
    }
    return offset;
}


vec4 donorSitePositions( in uint site, in uint i )
{   
    return donorSiteData[ getDonorSiteOffset( site ) + i ];
}


vec4 donorSiteNormals( in uint site, in uint i )
{
    return donorSiteData[ getDonorSiteOffset( site ) + uDonorSiteGridSize[ site ] + i];
}


uint randomize( inout uint seed )
{   
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}


float rand( inout uint seed )
{
    float a = randomize( seed );   
    return float( a/1.000001) * (1.0 / 4294967296.0);  // return 0 <= r < 1 
}


void shuffle( inout uint array[PL_MAX_GRAFTS_PER_SOLUTION], in uint size, inout uint seed )
{   
    for (uint i = 0; i < size; i++) 
    {
        uint j = uint(rand( seed ) * float(size) ); //i + uint( rand( seed ) * float(size - i) );
        uint t = array[j];
        array[j] = array[i];
        array[i] = t;
    }    
}


float rms( in uint graftIndex, in uint gridIndex )
{
    return rmsInput[ gridIndex*PL_MAX_GRAFTS_PER_SOLUTION + graftIndex ];
}


bool isSelectionValid( in uint gridIndex, in uint graftIndices[PL_MAX_GRAFTS_PER_SOLUTION], in uint solutionIndices[PL_MAX_GRAFTS_PER_SOLUTION], in uint solutionCount )  
{
    bool result = true;
    
    // potential donor location
    uint candidateSite, candidateIndex;
    getDonorSiteAndIndex( candidateSite, candidateIndex, gridIndex);
    
    // check against all locations in current solution
    for (uint i=0; i < solutionCount; i++)
    {
        uint site, localIndex;
        getDonorSiteAndIndex( site, localIndex, solutionIndices[ i ] );
    
        float combinedRadius = uGraftRadii[ graftIndices[solutionCount] ] + uGraftRadii[ graftIndices[i] ];
    
        if ( distance( donorSitePositions( candidateSite, candidateIndex ),  donorSitePositions( site, localIndex ) ) < combinedRadius )
        {
            // overlap, reject
            result = false;
            break;
        }
    }
    
    return result;
}



void main(void)
{ 
    // get invocation unique seed value for RNG
    uint seed = uint( uSeed*(gl_GlobalInvocationID.x+1) );

    // set min rms total to max value
    float minTotalRMS = PL_FLT_MAX;

    for ( uint k=0; k < PL_ITERATIONS; k++)
    {
        float currentTotalRMS = 0;
        
        uint solutionIndices[PL_MAX_GRAFTS_PER_SOLUTION];   
        uint graftIndices   [PL_MAX_GRAFTS_PER_SOLUTION];   // shuffled graft indices
        for (uint i=0; i < uGraftCount; i++)
        {
            graftIndices[i] = i;
        }
        shuffle( graftIndices, uGraftCount, seed );
        
        // for each graft
        for ( uint i=0; i < uGraftCount; i++ )
        {    
            uint graftIndex = graftIndices[i];
        
            float lowestRMS = PL_FLT_MAX;
            int   lowestGridpoint = -1;
            
            // for each grid point, find valid with lowest RMS
            for ( uint j=0; j < uTotalGridPoints; j++ )
            {
                float currentRMS = rms( graftIndex, j );

                if ( currentRMS > 0 && currentRMS < lowestRMS )
                {
                    if ( isSelectionValid( j, graftIndices, solutionIndices, i ) )
                    {                       
                        lowestGridpoint = int(j);
                        lowestRMS = currentRMS;
                    }                
                }
            }
            
            if ( lowestGridpoint == -1 )
            {
                // cannot find donor site for graft, abort this solution
                currentTotalRMS = PL_FLT_MAX;
                break;
            }    
            
            // increment rms total
            currentTotalRMS += lowestRMS;
            
            // set gridpoint index for graft
            solutionIndices[i] = lowestGridpoint;
        }

        if ( currentTotalRMS < minTotalRMS )
        {
            // save new min RMS
            minTotalRMS = currentTotalRMS;
            
            // export harvest locations and normals
            for (uint i=0; i < uGraftCount; i++)
            {
                uint offset = gl_GlobalInvocationID.x * PL_MAX_GRAFTS_PER_SOLUTION;        
                uint graftIndex = graftIndices[i];
                        
                uint site, localIndex;
                getDonorSiteAndIndex( site, localIndex, solutionIndices[i] );
            
                donorPositionsOutput [ offset + graftIndex ] = donorSitePositions( site, localIndex );
                donorNormalsOutput   [ offset + graftIndex ] = donorSiteNormals  ( site, localIndex );
                donorZDirectionOutput[ offset + graftIndex ] = donorSiteNormals  ( site, localIndex );                
            }
            
            // export total rms
            totalRmsOutput[ gl_GlobalInvocationID.x ] = minTotalRMS;
        }
    
    }
    
}


