#version 430

#define PL_NUM_WORKGROUPS           16
#define PL_MAX_GRAFTS_PER_SOLUTION  16
#define PL_MAX_RADIUS               4.0
#define PL_MIN_RADIUS               3.0
#define PL_OVERLAP_THRESHOLD        0.8

#define PL_MIN_PERTURBATION         0.05

layout (local_size_x = 64) in;

// shader storage buffer objects
layout (std430,  binding = 0) buffer siteDataBlock        { vec4 siteData[]; };

// temporary buffer
layout (std430,  binding = 1) buffer tempBuffer           { float overlappedTriangles[]; };

// output buffers
layout (std430,  binding = 2) buffer invoEnergiesBlock    { float invoEnergies      []; };
layout (std430,  binding = 3) buffer StatePositionBlock   { vec4  invoGraftPositions[]; };
layout (std430,  binding = 4) buffer StateNormalBlock     { vec4  invoGraftNormals  []; };
layout (std430,  binding = 5) buffer StateRadiiBlock      { float invoGraftRadii    []; };
layout (std430,  binding = 6) buffer StateGraftCountBlock { uint  invoGraftCounts   []; };


layout (std430,  binding = 7) buffer workGroupStates
{
    float groupEnergies       [ PL_NUM_WORKGROUPS ];
    uint  groupGraftCounts    [ PL_NUM_WORKGROUPS ];
    vec4  groupGraftPositions [ PL_NUM_WORKGROUPS * PL_MAX_GRAFTS_PER_SOLUTION ];
    vec4  groupGraftNormals   [ PL_NUM_WORKGROUPS * PL_MAX_GRAFTS_PER_SOLUTION ];
    float groupGraftRadii     [ PL_NUM_WORKGROUPS * PL_MAX_GRAFTS_PER_SOLUTION ];         
};


// site uniforms
uniform uint  uSiteMeshSize;
uniform float uSiteMeshArea;
uniform uint  uSiteGridSize;
uniform uint  uSitePerimSize;

/*
// current best state uniforms
uniform GroupStateUniforms
{
    float uStateTemperature;
    float uinvoEnergies       [PL_NUM_WORKGROUPS];
    uint  uinvoGraftCounts    [PL_NUM_WORKGROUPS];
    vec4  uinvoGraftPositions [PL_NUM_WORKGROUPS*PL_MAX_GRAFTS_PER_SOLUTION];
    vec4  uinvoGraftNormals   [PL_NUM_WORKGROUPS*PL_MAX_GRAFTS_PER_SOLUTION];
    float uinvoGraftRadii     [PL_NUM_WORKGROUPS*PL_MAX_GRAFTS_PER_SOLUTION];
};
*/

uniform float uStateTemperature;
uniform uint uSeed;
uniform uint uLoadLocal;


struct triangle
{
    vec3 p0;
    vec3 p1;
    vec3 p2;
    vec3 n;
};


struct edge
{
    vec3 p0;
    vec3 p1;
    vec3 n;
};


struct state
{
    vec4  positions     [PL_MAX_GRAFTS_PER_SOLUTION];
    vec4  normals       [PL_MAX_GRAFTS_PER_SOLUTION];
    float radii         [PL_MAX_GRAFTS_PER_SOLUTION];
    uint  graftCount;
    float energy;
};


void setOverlap( in uint index, in float value )
{
    overlappedTriangles[gl_GlobalInvocationID.x*uSiteMeshSize + index] = value;
}


float getOverlap( in uint index )
{
    return overlappedTriangles[gl_GlobalInvocationID.x*uSiteMeshSize + index];
}


vec4 sitePositions( in uint i )
{
    return siteData[i];
}


vec4 siteNormals( in uint i )
{
    return siteData[uSiteGridSize+i];
}


triangle siteTriangles( in uint i )
{
    uint j = uSiteGridSize*2 + i*4;    
    triangle t;
    t.p0 = vec3( siteData[j+0] );
    t.p1 = vec3( siteData[j+1] );
    t.p2 = vec3( siteData[j+2] );
    t.n  = vec3( siteData[j+3] );
    return t;
}


edge siteEdge( in uint i )
{
    uint offset = uSiteGridSize*2 + uSiteMeshSize*4;
    uint j = offset + i;
    uint k = offset + ( (i+1) % uSitePerimSize );
    
    edge e;
    e.p0 = vec3( siteData[ j ] );
    e.p1 = vec3( siteData[ k ] );  
    e.n  = vec3( siteData[ j+uSitePerimSize ] );    
    return e;
}

vec3 projectOntoPlane( in vec3 point, in vec3 plane_normal )
{
    float dist = dot( point, plane_normal);    
    return point - (dist * plane_normal);
}

float distToAxis( in vec3 axis, in vec3 v )    
{
    // v is already in the *local* coordinate system of the graft        
    return distance( v, dot(v, axis)*axis );
}

vec3 closestPointOnSegment( in vec3 p, in edge e)
{
    vec3 ab = e.p1 - e.p0;
    float t = dot( (p - e.p0), ab) / dot(ab, ab);
    // If outside segment, clamp t (and therefore d) to the closest endpoint
    t = clamp( t, 0.0, 1.0 );
    // Compute projected position from the clamped t
    return e.p0 + t * ab;
}

bool isWithinOverlapThreshold( in vec3 pos, in float threshold )
{
    bool inside = true;
    for (int i=0; i<uSitePerimSize; i++)
    {
        edge e = siteEdge( i );
        if ( distance( pos, closestPointOnSegment( pos, e) ) < threshold )
        {
            inside = false;
        }        
    }    
    return inside;
}

bool isValidPerturbation( in vec3 pos, in float threshold )
{
    bool inside = true;
    for (int i=0; i<uSitePerimSize; i++)
    {
        edge e = siteEdge( i );
        if ( dot( pos-e.p0, e.n ) > 0.0 ||
             distance( pos, closestPointOnSegment( pos, e) ) < threshold)
        {
            inside = false;
        }        
    }    
    return inside;
}

uint randomize( inout uint seed )
{   
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

float rand( inout uint seed )
{
    float a = randomize( seed );   
    return float( a/1.000001) * (1.0 / 4294967296.0);  // return 0 <= r < 1 
}


bool intersectTriangle( in vec3 position, in vec3 normal, in triangle t, in float radius ) 
{
    if ( dot(t.n, normal) < 0 )
        return false;

    // get vector from graft centre to triangle point
    vec3 point0 = t.p0 - position;
    vec3 point1 = t.p1 - position;
    vec3 point2 = t.p2 - position;
    
    return ( distToAxis( normal, point0 ) < radius ||
             distToAxis( normal, point1 ) < radius ||
             distToAxis( normal, point2 ) < radius );
  
}


float area( in triangle t)
{
    return 0.5 * length( cross( (t.p1 - t.p0),  (t.p2 - t.p0) ) );
}


float area_uncovered( in state s )
{           
    float overlapped_area = 0;    
    // iterate over triangles, if they are in cap, value > 0, add to sum
    for (uint i = 0; i < uSiteMeshSize; i++)
    {        
         overlapped_area += getOverlap( i );   
         setOverlap( i, 0 );   
    }          
    return uSiteMeshArea - overlapped_area;
}


float calculateCap( in vec4 position, in vec4 normal, in float radius ) //in uint index, in mat4 perturbation )
{   
    float area_sum = 0;

    // iterate through each triangle in mesh
    for(uint i=0; i<uSiteMeshSize; i++)
    {
        // create triangle struct
        triangle t = siteTriangles( i );

        if ( intersectTriangle( vec3( position ), vec3( normal ),  t, radius ) )  
        {
            float t_area = area( t );
            area_sum += t_area;  
            setOverlap( i, t_area ); 
        }  
    }
    return area_sum;
}

void rotate( inout mat4 mat, in float angle, in vec3 axis ) 
{
    float x = axis.x;
    float y = axis.y;
    float z = axis.z;

    // all angles in radians
    float s = sin( angle*0.017453292 );
    float c = cos( angle*0.017453292 );

    float mag = length( axis ); 

    // zero vector, return identity
    if (mag == 0.0) 
    {
        mat = mat4(1.0);
        return;
    }

    // Rotation matrix is normalized
    x /= mag;
    y /= mag;
    z /= mag;

    float xx, yy, zz, xy, yz, zx, xs, ys, zs, one_c;
    xx = x * x;
    yy = y * y;
    zz = z * z;
    xy = x * y;
    yz = y * z;
    zx = z * x;
    xs = x * s;
    ys = y * s;
    zs = z * s;
    one_c = 1.0f - c;

    mat = mat4(1.0);
    
    mat[0][0] = (one_c * xx) + c;
    mat[0][1] = (one_c * xy) - zs;
    mat[0][2] = (one_c * zx) + ys;

    mat[1][0] = (one_c * xy) + zs;
    mat[1][1] = (one_c * yy) + c;
    mat[1][2] = (one_c * yz) - xs;
    
    mat[2][0] = (one_c * zx) - ys;
    mat[2][1] = (one_c * yz) + xs;
    mat[2][2] = (one_c * zz) + c;
}


float energy ( in state s )
{
    float total_area_covered = 0;   // includes overlaps
    for (uint i=0; i<s.graftCount; i++)
    {
         // calculate cap returns area from the cap, and also flags any overlapped triangles
         total_area_covered += calculateCap( s.positions[i], s.normals[i], s.radii[i] ); 
    }

    // calculate energy
    float WEIGHT = 0.4;
    return area_uncovered( s ) + WEIGHT * total_area_covered;
}


void addCap( inout state s, inout uint seed )
{   
    /*
    float radius; 
    // iterate over indices until valid position is chosen
    uint index;
    do
    {
        radius = uint( rand( seed ) * (PL_MAX_RADIUS-PL_MIN_RADIUS+1) + PL_MIN_RADIUS); 
        index  = uint( uSiteGridSize*rand( seed ) );
    }
    while ( !isWithinOverlapThreshold( vec3( sitePositions( index ) ), radius*PL_OVERLAP_THRESHOLD ) );

    s.positions[s.graftCount] = sitePositions( index );
    s.normals  [s.graftCount] = siteNormals  ( index );
    s.radii    [s.graftCount] = radius;   
    s.graftCount++;  
    */
    
    float radius = uint( rand( seed ) * (PL_MAX_RADIUS-PL_MIN_RADIUS+1) + PL_MIN_RADIUS); 
    uint  index  = uint( uSiteGridSize*rand( seed ) );
    
    if ( isWithinOverlapThreshold( vec3( sitePositions( index ) ), radius*PL_OVERLAP_THRESHOLD ) )
    {    
        s.positions[s.graftCount] = sitePositions( index );
        s.normals  [s.graftCount] = siteNormals  ( index );
        s.radii    [s.graftCount] = radius;   
        s.graftCount++;  
    }
}


void removeCap( inout state s, inout uint seed )
{ 
    uint index = uint( s.graftCount*rand( seed ) );
    
    // shift all other elements down
    for (uint i=index; i<s.graftCount; i++)
    {
        if (i+1 == PL_MAX_GRAFTS_PER_SOLUTION)  // max sure doesnt go out of bounds
        {
            s.positions[i] = vec4(-1, -1, -1, -1);
            s.normals  [i] = vec4(-1, -1, -1, -1);
            s.radii    [i] = -1.0; 
        }    
        s.positions[i] = s.positions[i+1];
        s.normals  [i] = s.normals  [i+1];
        s.radii    [i] = s.radii    [i+1];                              
    }
    s.graftCount--;
}




void perturbState( inout state s, inout uint seed )
{
    
    float perturbationScale = ( uStateTemperature > PL_MIN_PERTURBATION ) ? uStateTemperature : rand( seed ) * PL_MIN_PERTURBATION; //(2.0 * uStateTemperature) + 1.0; // at minimum perturbation will range 0 - 0.5   
             
    for (uint i=0; i<s.graftCount; i++)
    {
        /*
        // get random rotation        
        float angle = ((rand( seed )*2.0)-1.0) * perturbationScale;
        float x = rand( seed );
        float y = rand( seed );
        float z = rand( seed );    
        vec3 axis = normalize( vec3( x, y, z ) );
        mat4 rot;   rotate( rot, angle, axis ); 
        */
        
        /*
        vec3 trans;
        uint c = 0;
        do
        {
            // get random translation
            float tx = rand( seed );
            float ty = rand( seed );
            float tz = rand( seed ); 

            vec3 projectedTrans = projectOntoPlane( vec3( tx, ty, tz ), vec3( s.normals[i] ) );
                
            trans = normalize( projectedTrans ) * ( ((rand( seed )*2.0)-1.0) * perturbationScale);
            c++;
        }
        while ( !isValidPerturbation( vec3( s.positions[i] ) + trans, s.radii[i]*PL_OVERLAP_THRESHOLD ) && c < 3 );    
        
        s.positions[i] = s.positions[i] + vec4(trans, 1.0);
        */
        
        // get random translation
        float tx = rand( seed );
        float ty = rand( seed );
        float tz = rand( seed ); 

        vec3 projectedTrans = projectOntoPlane( vec3( tx, ty, tz ), vec3( s.normals[i] ) );           
        vec3 trans          = normalize( projectedTrans ) * ( ((rand( seed )*2.0)-1.0) * perturbationScale);

        if ( isValidPerturbation( vec3( s.positions[i] ) + trans, s.radii[i]*PL_OVERLAP_THRESHOLD ) )    
        {
            s.positions[i] = s.positions[i] + vec4( trans, 1.0 );
        }
            
        //s.normals  [i] = vec4( normalize( mat3( rot[0], rot[1], rot[2]) * vec3(s.normals[i]) ), 1.0 );

    }
}


void copyState( inout state s, in state S )
{
    s.graftCount = S.graftCount;
    for (int i=0; i<s.graftCount; i++)
    {       
        s.positions[i] = S.positions[i];
        s.normals  [i] = S.normals  [i];
        s.radii    [i] = S.radii    [i];
    }
    s.energy = S.energy;
}


void copyGlobalState( inout state s )
{
    uint offset = gl_WorkGroupID.x*PL_MAX_GRAFTS_PER_SOLUTION;

    s.graftCount = groupGraftCounts[ gl_WorkGroupID.x ];
    s.energy     = groupEnergies   [ gl_WorkGroupID.x ];
    
    for (int i=0; i<s.graftCount; i++)
    {       
        s.positions[i] = groupGraftPositions[offset+i];
        s.normals  [i] = groupGraftNormals  [offset+i];
        s.radii    [i] = groupGraftRadii    [offset+i];
    } 
}


void copyLocalState( inout state s )
{
    uint offset = gl_GlobalInvocationID.x*PL_MAX_GRAFTS_PER_SOLUTION;  

    s.graftCount = invoGraftCounts[ gl_GlobalInvocationID.x ];
    s.energy     = invoEnergies   [ gl_GlobalInvocationID.x ];
    
    for (int i=0; i<s.graftCount; i++)
    {       
        s.positions[i] = invoGraftPositions[offset+i];
        s.normals  [i] = invoGraftNormals  [offset+i];
        s.radii    [i] = invoGraftRadii    [offset+i];
    }    
}

/*
float acceptanceProbability( in float energy, in float newEnergy) 
{
    float result;
    // If the new solution is better, accept it
    if (newEnergy < energy) 
    {
        result = 1.0;
    }
    else
    {
        // If the new solution is worse, calculate an acceptance probability
        result = exp( -(newEnergy - energy) / uStateTemperature );
    }
    return result;
}
*/

/*


void main(void)
{ 
    // get global invocation id
    int gid = int( gl_GlobalInvocationID.x );  
      

    // get invocation unique seed value for RNG
    uint seed = uint( uSeed*(gid+1) );  
       
    // create local state and copy data from global state 
    state S;   copyGlobalState(  S ); 
    state nS;  copyGlobalState( nS ); 
    
    for (uint j=0; j < PL_ITERATIONS; j++)
    {   
        // determine which case
        uint changeCase = uint( rand( seed ) * 3 );
            
        if (nS.graftCount == 0 || changeCase == 0)
        {
            // add random
            if (nS.graftCount < PL_MAX_GRAFTS_PER_SOLUTION)
            {
                addCap( nS, seed );
            }
        }
        else if (changeCase == 1)
        {
            // remove random
            removeCap( nS, seed );
        }
        
        // peturb state
        perturbState( nS, seed );
        
        // calc energy
        nS.energy = energy( nS );
        
        if ( acceptanceProbability( S.energy, nS.energy ) > rand( seed ) )
        {
            copyState( S, nS );
        }  
    }
    
    // store state energy
    invoEnergies[gid] = S.energy;

    // store state graft count
    invoGraftCounts[gid] = S.graftCount;

    // store state positions, normals, and radii  
    uint offset = gid*PL_MAX_GRAFTS_PER_SOLUTION;  
    for (int i=0; i<S.graftCount; i++)
    {
        invoGraftPositions[offset+i] = S.positions[i];
        invoGraftNormals  [offset+i] = S.normals  [i]; 
        invoGraftRadii    [offset+i] = S.radii    [i];   
    }
    
}
*/


void main(void)
{ 
    // get global invocation id
    uint gid = gl_GlobalInvocationID.x;  
      
    // get invocation unique seed value for RNG
    uint seed = uint( uSeed*(gid+1) );  
    
    // acquire current state (whether global or local)  
    state nS;   
    if ( uLoadLocal > 0 )  
    {       
        copyLocalState( nS );        
    }
    else   
    {       
        copyGlobalState( nS );         
    }

    
    // determine which case
    uint changeCase = uint( rand( seed ) * 3 );
        
    if (nS.graftCount == 0 || changeCase == 0)
    {
        // add random
        if (nS.graftCount < PL_MAX_GRAFTS_PER_SOLUTION)
        {
            addCap( nS, seed );
        }
    }
    else if (changeCase == 1)
    {
        // remove random
        removeCap( nS, seed );
    }
             
    // peturb state
    perturbState( nS, seed );
    
    if ( uLoadLocal == 1 )
    {
        // calc energy
        nS.energy = energy( nS );             
    }
    
    // store state energy
    invoEnergies[gid] = nS.energy;
    
    // store state graft count
    invoGraftCounts[gid] = nS.graftCount;

    // store state positions, normals, and radii  
    uint offset = gid*PL_MAX_GRAFTS_PER_SOLUTION;  
    for (int i=0; i<nS.graftCount; i++)
    {
        invoGraftPositions[offset+i] = nS.positions[i];
        invoGraftNormals  [offset+i] = nS.normals  [i]; 
        invoGraftRadii    [offset+i] = nS.radii    [i];   
    } 
}


