#version 430

#define PL_FLT_MAX                  999999
#define PL_MAX_GRAFTS_PER_SOLUTION  16
#define PL_MAX_DONOR_SITES          5
#define PL_PLUG_LENGTH              15.0

layout (local_size_x = 256) in;

// input data
layout (std430,  binding = 0) buffer donorSiteDataBlock   { vec4 donorSiteData[];  };
layout (std430,  binding = 1) buffer rmsValuesBlock       { float rmsValues[];     };
layout (std430,  binding = 2) buffer rmsDirectionsBlock   { vec4  rmsDirections[]; };
// output data
layout (std430,  binding = 3) buffer donorPositionsBlock   { vec4  donorPositionsOutput  []; };
layout (std430,  binding = 4) buffer donorNormalsBlock     { vec4  donorNormalsOutput    []; };
layout (std430,  binding = 5) buffer donorDirectionsBlock  { vec4  donorZDirectionOutput []; };
layout (std430,  binding = 6) buffer totalRmsBlock         { float totalRmsOutput[];         };

// input uniforms
uniform uint  uGraftCount;
uniform float uGraftRadii     [PL_MAX_GRAFTS_PER_SOLUTION];

uniform uint  uTotalGridPoints;
uniform uint  uDonorSiteCount;
uniform uint  uDonorSiteGridSize   [PL_MAX_DONOR_SITES];
uniform uint  uDonorSiteDataOffset [PL_MAX_DONOR_SITES];

uniform uint  uNumDirections;

uniform uint  uSeed;

void getDonorSiteAndIndex( inout uint site, inout uint localIndex, in uint globalIndex )
{
    localIndex = globalIndex;
    for (uint i=0; i<uDonorSiteCount; i++)
    {
        if ( localIndex < uDonorSiteGridSize[ i ] )
        {
            site = i;
            break;
        }
        localIndex -= uDonorSiteGridSize[ i ];
    }
}


vec4 donorSitePositions( in uint site, in uint i )
{   
    return donorSiteData[ uDonorSiteDataOffset[ site ] + i ];
}


vec4 donorSiteNormals( in uint site, in uint i )
{
    return donorSiteData[ uDonorSiteDataOffset[ site ] + uDonorSiteGridSize[ site ] + i];
}


uint randomize( inout uint seed )
{   
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}


float rand( inout uint seed )
{
    float a = randomize( seed );   
    return float( a/1.000001) * (1.0 / 4294967296.0);  // return 0 <= r < 1 
}


void getShuffledIndexArray( inout uint array[PL_MAX_GRAFTS_PER_SOLUTION], in uint size, inout uint seed )
{   
    // fill array with incremental indices
    for (uint i=0; i < size; i++)
    {
        array[i] = i;
    }

    // randomize orders
    for (uint i = 0; i < size; i++) 
    {
        uint j = uint( rand( seed ) * float( size ) );
        uint t = array[j];
        array[j] = array[i];
        array[i] = t;
    }    
}

/*
void shuffle( inout uint array[PL_MAX_GRAFTS_PER_SOLUTION], in uint size, inout uint seed )
{   
    for (uint i = 0; i < size; i++) 
    {
        uint j = uint( rand( seed ) * float( size ) ); //i + uint( rand( seed ) * float(size - i) );
        uint t = array[j];
        array[j] = array[i];
        array[i] = t;
    }    
}
*/


float rms( in uint graftIndex, in uint gridIndex, in uint directionIndex )
{
    return rmsValues[ (uTotalGridPoints*PL_MAX_GRAFTS_PER_SOLUTION*directionIndex) + (PL_MAX_GRAFTS_PER_SOLUTION*gridIndex) + graftIndex ];
}


bool isSelectionValid( in uint gridIndex, in uint graftIndices[PL_MAX_GRAFTS_PER_SOLUTION], in uint solutionIndices[PL_MAX_GRAFTS_PER_SOLUTION], in uint solutionCount )  
{
    bool result = true;
    
    // potential donor location
    uint candidateSite, candidateIndex;
    getDonorSiteAndIndex( candidateSite, candidateIndex, gridIndex);
    
    // check against all locations in current solution
    for (uint i=0; i < solutionCount; i++)
    {
        uint site, localIndex;
        getDonorSiteAndIndex( site, localIndex, solutionIndices[ i ] );
    
        float combinedRadius = uGraftRadii[ graftIndices[solutionCount] ] + uGraftRadii[ graftIndices[i] ];
    
        if ( distance( donorSitePositions( candidateSite, candidateIndex ),  donorSitePositions( site, localIndex ) ) < combinedRadius )
        {
            // overlap, reject
            result = false;
            break;
        }
    }
    
    return result;
}



void main(void)
{ 
    // get invocation unique seed value for RNG
    uint seed = uint( uSeed*(gl_GlobalInvocationID.x+1) );

    float totalRMS = 0;
    
    uint solutionIndices   [PL_MAX_GRAFTS_PER_SOLUTION];   
    uint solutionDirections[PL_MAX_GRAFTS_PER_SOLUTION]; 
      
    uint graftIndices      [PL_MAX_GRAFTS_PER_SOLUTION];   // shuffled graft indices        
    /*
    for (uint i=0; i < uGraftCount; i++)
    {
        graftIndices[i] = i;
    }
    shuffle( graftIndices, uGraftCount, seed ); */
    getShuffledIndexArray( graftIndices, uGraftCount, seed );


    // for each graft
    for ( uint i=0; i < uGraftCount; i++ )
    {    
        uint graftIndex = graftIndices[i];
    
        float lowestRMS       = PL_FLT_MAX;
        int   lowestGridpoint = -1;
        int   lowestDirection = -1;
        // for each grid point, find valid with lowest RMS
        for ( uint j=0; j < uTotalGridPoints; j++ )
        {     
            // for each direction, find valid with lowest RMS
            for ( uint k=0; k < uNumDirections; k++ )
            {            
                float currentRMS = rms( graftIndex, j, k );

                if ( currentRMS > 0 && currentRMS < lowestRMS )
                {
                    if ( isSelectionValid( j, graftIndices, solutionIndices, i ) )
                    {     
                        lowestRMS = currentRMS;                  
                        lowestGridpoint = int(j);                            
                        lowestDirection = int(k);
                    }                
                }
        
            }
            
        }
        
        if ( lowestGridpoint == -1 )
        {
            // cannot find donor site for graft, abort this solution
            return;
        }    
        
        // increment rms total
        totalRMS += lowestRMS;
        
        // set gridpoint and direction index for graft
        solutionIndices   [i] = lowestGridpoint;
        solutionDirections[i] = lowestDirection;
    }


    // export harvest locations and normals
    for (uint i=0; i < uGraftCount; i++)
    {
        uint offset = gl_GlobalInvocationID.x * PL_MAX_GRAFTS_PER_SOLUTION;        
        uint graftIndex = graftIndices[i];
                
        uint site, localIndex;
        getDonorSiteAndIndex( site, localIndex, solutionIndices[i] );
    
        donorPositionsOutput [ offset + graftIndex ] = donorSitePositions( site, localIndex );
        donorNormalsOutput   [ offset + graftIndex ] = donorSiteNormals  ( site, localIndex );
        donorZDirectionOutput[ offset + graftIndex ] = rmsDirections[ solutionDirections[i] ];               
    }
    
    // export total rms
    totalRmsOutput[ gl_GlobalInvocationID.x ] = totalRMS;

    
}


