

//functions

float energy(in state s)
{
    for (uint i=0; i<s.graftCount; i++)
    {
         // calculate cap returns area from the cap, and also flags any overlapped triangles
         calculateCapAreaCoverage(s.positions[i], s.normals[i], s.radii[i]);
    }
    return uncoveredArea(s) + (graftOverlap(s) * PL_STAGE_0_GRAFT_INTERSECTION_PENALTY) + (s.graftCount * PL_STAGE_0_GRAFT_COUNT_PENALTY);
}


void calculateCapAreaCoverage(in vec4 position, in vec4 normal, in float radius)
{
    // iterate through each triangle in mesh
    for(uint i=0; i<uDefectSiteTriangleCount; i++)
    {
        // create triangle struct
        triangle t = defectSiteTriangles(i);

        if (graftIntersectTriangle(vec3(position), vec3(normal),  t, radius))
        {
            setCapOverlap(i, area(t));
        }
    }

}


float uncoveredArea(in state s)
{
    float coveredArea = 0.0;
    // iterate over triangles, if they are in cap, value > 0, add to sum
    for (uint i = 0; i < uDefectSiteTriangleCount; i++)
    {
         coveredArea += getCapOverlap(i);
         // reset overlap to 0 for next time
         setCapOverlap(i, 0);
    }
    return uDefectSiteArea - coveredArea;
}


float graftOverlap(in state s)
{
    float totalOverlap = 0;
    for (uint i=0; i < s.graftCount; i++)
    {
        for (uint j=i+1; j < s.graftCount; j++)
        {
            totalOverlap += cylinderOverlap(s.positions[i].xyz, s.normals[i].xyz, s.radii[i],
                                             s.positions[j].xyz, s.normals[j].xyz, s.radii[j]);
        }
    }
    return totalOverlap;
}


void setCapOverlap(in uint index, in float value)
{
    triangleAreaOverlap[ gl_GlobalInvocationID.x*uDefectSiteTriangleCount + index ] = value;
}


float getCapOverlap(in uint index)
{
    return triangleAreaOverlap[ gl_GlobalInvocationID.x*uDefectSiteTriangleCount + index ];
}


float acceptanceProbability(in float energy, in float newEnergy)
{
    // If the new solution is better, accept it
    if (newEnergy < energy)
    {
        return 1.0f;
    }
    // If the new solution is worse, calculate an acceptance probability
    return exp(-(newEnergy - energy) / uTemperature);
}
